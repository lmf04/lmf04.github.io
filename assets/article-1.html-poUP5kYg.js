import{_ as e,e as n,g as o,o as r}from"./app-CrqbF7DL.js";const a={};function s(i,t){return r(),n("div",null,t[0]||(t[0]=[o('<p>在 Python 2.5 中， with 关键字被加入。它将常用的 try ... except ... finally ... 模式很方便的被复用。看一个最经典的例子： with open(&#39;file.txt&#39;) as f: content = f.read() 在这段代码中，无论 with 中的代码块在执行的过程中发生任何情况，文件最终都会被关闭。如果代码块在执行的过程中发生了一个异常，那么在这个异常被抛出前，程序会先将被打开的文件关闭。</p><p>再看另外一个例子。</p><p>在发起一个数据库事务请求的时候，经常会用类似这样的代码：</p><p>db.begin()</p><p>try:</p><h1 id="do-some-actions" tabindex="-1"><a class="header-anchor" href="#do-some-actions"><span>do some actions</span></a></h1><p>except: db.rollback() raise finally: db.commit() 如果将发起事务请求的操作变成可以支持 with 关键字的，那么用像这样的代码就可以了：</p><p>with transaction(db):</p><h1 id="do-some-actions-1" tabindex="-1"><a class="header-anchor" href="#do-some-actions-1"><span>do some actions</span></a></h1><p>下面，详细的说明一下 with 的执行过程，并用两种常用的方式实现上面的代码。</p><p>with 的一般执行过程</p><p>一段基本的 with 表达式，其结构是这样的：</p><p>with EXPR as VAR: BLOCK 其中： EXPR 可以是任意表达式； as VAR 是可选的。其一般的执行过程是这样的：</p><p>计算 EXPR ，并获取一个上下文管理器。 上下文管理器的 <strong>exit()</strong> 方法被保存起来用于之后的调用。 调用上下文管理器的 <strong>enter()</strong> 方法。 如果 with 表达式包含 as VAR ，那么 EXPR 的返回值被赋值给 VAR 。 执行 BLOCK 中的表达式。 调用上下文管理器的 <strong>exit()</strong> 方法。如果 BLOCK 的执行过程中发生了一个异常导致程序退出，那么异常的 type 、 value 和 traceback (即 sys.exc_info()的返回值 )将作为参数传递给 <strong>exit()</strong> 方法。否则，将传递三个 None 。 将这个过程用代码表示，是这样的：</p><p>mgr = (EXPR) exit = type(mgr).<strong>exit</strong> # 这里没有执行 value = type(mgr).<strong>enter</strong>(mgr) exc = True</p><p>try: try: VAR = value # 如果有 as VAR BLOCK except: exc = False if not exit(mgr, *sys.exc_info()): raise finally: if exc: exit(mgr, None, None, None) 这个过程有几个细节：</p><p>如果上下文管理器中没有 <strong>enter()</strong> 或者 <strong>exit()</strong> 中的任意一个方法，那么解释器会抛出一个 AttributeError 。 在 BLOCK 中发生异常后，如果 <strong>exit()</strong> 方法返回一个可被看成是 True 的值，那么这个异常就不会被抛出，后面的代码会继续执行。</p><p>接下来，用两种方法来实现上面来实现上面的过程的吧。</p><p>实现上下文管理器类</p><p>第一种方法是实现一个类，其含有一个实例属性 db 和上下文管理器所需要的方法 <strong>enter()</strong> 和 <strong>exit()</strong> 。</p><p>class transaction(object): def <strong>init</strong>(self, db): self.db = db</p><p>def <strong>enter</strong>(self): self.db.begin()</p><p>def <strong>exit</strong>(self, type, value, traceback): if type is None: db.commit() else: db.rollback() 了解 with 的执行过程后，这个实现方式是很容易理解的。下面介绍的实现方式，其原理理解起来要复杂很多。</p><p>使用生成器装饰器</p><p>在Python的标准库中，有一个装饰器可以通过生成器获取上下文管理器。使用生成器装饰器的实现过程如下：</p><p>from contextlib import contextmanager</p><p>@contextmanager def transaction(db): db.begin()</p><p>try: yield db except: db.rollback() raise else: db.commit() 第一眼上看去，这种实现方式更为简单，但是其机制更为复杂。看一下其执行过程吧：</p><p>Python解释器识别到 yield 关键字后， def 会创建一个生成器函数替代常规的函数（在类定义之外我喜欢用函数代替方法）。 装饰器 contextmanager 被调用并返回一个帮助方法，这个帮助函数在被调用后会生成一个 GeneratorContextManager 实例。最终 with 表达式中的 EXPR 调用的是由 contentmanager 装饰器返回的帮助函数。 with 表达式调用 transaction(db) ，实际上是调用帮助函数。帮助函数调用生成器函数，生成器函数创建一个生成器。 帮助函数将这个生成器传递给 GeneratorContextManager ，并创建一个 GeneratorContextManager 的实例对象作为上下文管理器。 with 表达式调用实例对象的上下文管理器的 <strong>enter()</strong> 方法。 <strong>enter()</strong> 方法中会调用这个生成器的 next() 方法。这时候，生成器方法会执行到 yield db 处停止，并将 db 作为 next() 的返回值。如果有 as VAR ，那么它将会被赋值给 VAR 。 with 中的 BLOCK 被执行。 BLOCK 执行结束后，调用上下文管理器的 <strong>exit()</strong> 方法。 <strong>exit()</strong> 方法会再次调用生成器的 next() 方法。如果发生 StopIteration 异常，则 pass 。 如果没有发生异常生成器方法将会执行 db.commit() ，否则会执行 db.rollback() 。 再次看看上述过程的代码大致实现：</p><p>def contextmanager(func): def helper(*args, **kwargs): return GeneratorContextManager(func(*args, **kwargs)) return helper</p><p>class GeneratorContextManager(object): def <strong>init</strong>(self, gen): self.gen = gen</p><p>def <strong>enter</strong>(self): try: return self.gen.next() except StopIteration: raise RuntimeError(&quot;generator didn&#39;t yield&quot;)</p><p>def <strong>exit</strong>(self, type, value, traceback): if type is None: try: self.gen.next() except StopIteration: pass else: raise RuntimeError(&quot;generator didn&#39;t stop&quot;) else: try: self.gen.throw(type, value, traceback) raise RuntimeError(&quot;generator didn&#39;t stop after throw()&quot;) except StopIteration: return True except: if sys.exc_info()[1] is not value: raise 总结</p><p>Python的 with 表达式包含了很多Python特性。花点时间吃透 with 是一件非常值得的事情。</p><p>一些其他的例子</p><p>锁机制</p><p>@contextmanager def locked(lock): lock.acquired() try: yield finally: lock.release() 标准输出重定向</p><p>@contextmanager def stdout_redirect(new_stdout): old_stdout = sys.stdout sys.stdout = new_stdout try: yield finally: sys.stdout = old_stdout</p><p>with open(&quot;file.txt&quot;, &quot;w&quot;) as f: with stdout_redirect(f): print &quot;hello world&quot; 参考资料</p><p>The Python “with” Statement by Example</p>',40)]))}const l=e(a,[["render",s],["__file","article-1.html.vue"]]),c=JSON.parse(`{"path":"/zh/blog/article-1.html","title":"Python 中 with的详细用法","lang":"zh-CN","frontmatter":{"layout":"BlogPost","date":"2025.01.12","archive":true,"title":"Python 中 with的详细用法","description":"Python 2.5 中引入了 with 关键字，它提供了一种方便的方式来重用常见的 try ... except ... finally ...模式"},"headers":[],"git":{"updatedTime":1756009719000,"contributors":[{"name":"limengli","username":"limengli","email":"limengli@qq.com","commits":2,"url":"https://github.com/limengli"}],"changelog":[{"hash":"84a449896542c2afd785917d68f97d41e64b66fb","time":1756009719000,"email":"limengli@qq.com","author":"limengli","message":"update"},{"hash":"33fb064215db0208e223b56976bfe0fd34434077","time":1754478598000,"email":"limengli@qq.com","author":"limengli","message":"web"}]},"filePathRelative":"zh/blog/article-1.md","excerpt":"<p>在 Python 2.5 中， with 关键字被加入。它将常用的 try ... except ... finally ... 模式很方便的被复用。看一个最经典的例子：\\nwith open('file.txt') as f:\\ncontent = f.read()\\n在这段代码中，无论 with 中的代码块在执行的过程中发生任何情况，文件最终都会被关闭。如果代码块在执行的过程中发生了一个异常，那么在这个异常被抛出前，程序会先将被打开的文件关闭。</p>\\n<p>再看另外一个例子。</p>\\n<p>在发起一个数据库事务请求的时候，经常会用类似这样的代码：</p>\\n<p>db.begin()</p>"}`);export{l as comp,c as data};
