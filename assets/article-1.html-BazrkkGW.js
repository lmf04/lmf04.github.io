import{_ as e,e as o,g as n,o as r}from"./app-yQRFVPrG.js";const a={};function s(i,t){return r(),o("div",null,t[0]||(t[0]=[n('<p>在 Python 2.5 中， with 关键字被加入。它将常用的 try ... except ... finally ... 模式很方便的被复用。看一个最经典的例子： with open(&#39;file.txt&#39;) as f: content = f.read() 在这段代码中，无论 with 中的代码块在执行的过程中发生任何情况，文件最终都会被关闭。如果代码块在执行的过程中发生了一个异常，那么在这个异常被抛出前，程序会先将被打开的文件关闭。</p><p>再看另外一个例子。</p><p>在发起一个数据库事务请求的时候，经常会用类似这样的代码：</p><p>db.begin()</p><p>try:</p><h1 id="do-some-actions" tabindex="-1"><a class="header-anchor" href="#do-some-actions"><span>do some actions</span></a></h1><p>except: db.rollback() raise finally: db.commit() 如果将发起事务请求的操作变成可以支持 with 关键字的，那么用像这样的代码就可以了：</p><p>with transaction(db):</p><h1 id="do-some-actions-1" tabindex="-1"><a class="header-anchor" href="#do-some-actions-1"><span>do some actions</span></a></h1><p>下面，详细的说明一下 with 的执行过程，并用两种常用的方式实现上面的代码。</p><p>with 的一般执行过程</p><p>一段基本的 with 表达式，其结构是这样的：</p><p>with EXPR as VAR: BLOCK 其中： EXPR 可以是任意表达式； as VAR 是可选的。其一般的执行过程是这样的：</p><p>计算 EXPR ，并获取一个上下文管理器。 上下文管理器的 <strong>exit()</strong> 方法被保存起来用于之后的调用。 调用上下文管理器的 <strong>enter()</strong> 方法。 如果 with 表达式包含 as VAR ，那么 EXPR 的返回值被赋值给 VAR 。 执行 BLOCK 中的表达式。 调用上下文管理器的 <strong>exit()</strong> 方法。如果 BLOCK 的执行过程中发生了一个异常导致程序退出，那么异常的 type 、 value 和 traceback (即 sys.exc_info()的返回值 )将作为参数传递给 <strong>exit()</strong> 方法。否则，将传递三个 None 。 将这个过程用代码表示，是这样的：</p><p>mgr = (EXPR) exit = type(mgr).<strong>exit</strong> # 这里没有执行 value = type(mgr).<strong>enter</strong>(mgr) exc = True</p><p>try: try: VAR = value # 如果有 as VAR BLOCK except: exc = False if not exit(mgr, *sys.exc_info()): raise finally: if exc: exit(mgr, None, None, None) 这个过程有几个细节：</p><p>如果上下文管理器中没有 <strong>enter()</strong> 或者 <strong>exit()</strong> 中的任意一个方法，那么解释器会抛出一个 AttributeError 。 在 BLOCK 中发生异常后，如果 <strong>exit()</strong> 方法返回一个可被看成是 True 的值，那么这个异常就不会被抛出，后面的代码会继续执行。</p><p>接下来，用两种方法来实现上面来实现上面的过程的吧。</p><p>实现上下文管理器类</p><p>第一种方法是实现一个类，其含有一个实例属性 db 和上下文管理器所需要的方法 <strong>enter()</strong> 和 <strong>exit()</strong> 。</p><p>class transaction(object): def <strong>init</strong>(self, db): self.db = db</p><p>def <strong>enter</strong>(self): self.db.begin()</p><p>def <strong>exit</strong>(self, type, value, traceback): if type is None: db.commit() else: db.rollback() 了解 with 的执行过程后，这个实现方式是很容易理解的。下面介绍的实现方式，其原理理解起来要复杂很多。</p><p>使用生成器装饰器</p><p>在Python的标准库中，有一个装饰器可以通过生成器获取上下文管理器。使用生成器装饰器的实现过程如下：</p><p>from contextlib import contextmanager</p><p>@contextmanager def transaction(db): db.begin()</p><p>try: yield db except: db.rollback() raise else: db.commit() 第一眼上看去，这种实现方式更为简单，但是其机制更为复杂。看一下其执行过程吧：</p><p>Python解释器识别到 yield 关键字后， def 会创建一个生成器函数替代常规的函数（在类定义之外我喜欢用函数代替方法）。 装饰器 contextmanager 被调用并返回一个帮助方法，这个帮助函数在被调用后会生成一个 GeneratorContextManager 实例。最终 with 表达式中的 EXPR 调用的是由 contentmanager 装饰器返回的帮助函数。 with 表达式调用 transaction(db) ，实际上是调用帮助函数。帮助函数调用生成器函数，生成器函数创建一个生成器。 帮助函数将这个生成器传递给 GeneratorContextManager ，并创建一个 GeneratorContextManager 的实例对象作为上下文管理器。 with 表达式调用实例对象的上下文管理器的 <strong>enter()</strong> 方法。 <strong>enter()</strong> 方法中会调用这个生成器的 next() 方法。这时候，生成器方法会执行到 yield db 处停止，并将 db 作为 next() 的返回值。如果有 as VAR ，那么它将会被赋值给 VAR 。 with 中的 BLOCK 被执行。 BLOCK 执行结束后，调用上下文管理器的 <strong>exit()</strong> 方法。 <strong>exit()</strong> 方法会再次调用生成器的 next() 方法。如果发生 StopIteration 异常，则 pass 。 如果没有发生异常生成器方法将会执行 db.commit() ，否则会执行 db.rollback() 。 再次看看上述过程的代码大致实现：</p><p>def contextmanager(func): def helper(*args, **kwargs): return GeneratorContextManager(func(*args, **kwargs)) return helper</p><p>class GeneratorContextManager(object): def <strong>init</strong>(self, gen): self.gen = gen</p><p>def <strong>enter</strong>(self): try: return self.gen.next() except StopIteration: raise RuntimeError(&quot;generator didn&#39;t yield&quot;)</p><p>def <strong>exit</strong>(self, type, value, traceback): if type is None: try: self.gen.next() except StopIteration: pass else: raise RuntimeError(&quot;generator didn&#39;t stop&quot;) else: try: self.gen.throw(type, value, traceback) raise RuntimeError(&quot;generator didn&#39;t stop after throw()&quot;) except StopIteration: return True except: if sys.exc_info()[1] is not value: raise 总结</p><p>Python的 with 表达式包含了很多Python特性。花点时间吃透 with 是一件非常值得的事情。</p><p>一些其他的例子</p><p>锁机制</p><p>@contextmanager def locked(lock): lock.acquired() try: yield finally: lock.release() 标准输出重定向</p><p>@contextmanager def stdout_redirect(new_stdout): old_stdout = sys.stdout sys.stdout = new_stdout try: yield finally: sys.stdout = old_stdout</p><p>with open(&quot;file.txt&quot;, &quot;w&quot;) as f: with stdout_redirect(f): print &quot;hello world&quot; 参考资料</p><p>The Python “with” Statement by Example</p>',40)]))}const c=e(a,[["render",s],["__file","article-1.html.vue"]]),l=JSON.parse(`{"path":"/blog/article-1.html","title":"Python 中的with关键字使用详解","lang":"en-US","frontmatter":{"layout":"BlogPost","date":"2025.01.12","archive":true,"title":"Python 中的with关键字使用详解","description":"在 Python 2.5 中， with 关键字被加入。它将常用的 try ... except ... finally ... 模式很方便的被复用。看一个最经典的例"},"headers":[],"git":{"updatedTime":1741935172000,"contributors":[{"name":"2935580139@qq.com","username":"2935580139@qq.com","email":"2935580139@qq.com","commits":3,"url":"https://github.com/2935580139@qq.com"}],"changelog":[{"hash":"111f99791fc859f6161c5bc6e170c49ba8d87c0a","time":1741935172000,"email":"2935580139@qq.com","author":"2935580139@qq.com","message":"123"},{"hash":"0067cd900b57c2d5d286d793fd090266ceea4952","time":1741880611000,"email":"2935580139@qq.com","author":"2935580139@qq.com","message":"1"},{"hash":"2de90227ea5bda0ed1f22282a8f3f3289e48a111","time":1741848364000,"email":"2935580139@qq.com","author":"2935580139@qq.com","message":"init"}]},"filePathRelative":"blog/article-1.md","excerpt":"<p>在 Python 2.5 中， with 关键字被加入。它将常用的 try ... except ... finally ... 模式很方便的被复用。看一个最经典的例子：\\nwith open('file.txt') as f:\\ncontent = f.read()\\n在这段代码中，无论 with 中的代码块在执行的过程中发生任何情况，文件最终都会被关闭。如果代码块在执行的过程中发生了一个异常，那么在这个异常被抛出前，程序会先将被打开的文件关闭。</p>\\n<p>再看另外一个例子。</p>\\n<p>在发起一个数据库事务请求的时候，经常会用类似这样的代码：</p>\\n<p>db.begin()</p>"}`);export{c as comp,l as data};
