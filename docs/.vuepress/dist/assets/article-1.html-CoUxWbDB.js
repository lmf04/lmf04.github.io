import{_ as t,e as n,g as o,o as r}from"./app-OXf-X-ix.js";const a={};function i(s,e){return r(),n("div",null,e[0]||(e[0]=[o('<p>In Python 2.5, the with keyword was introduced. It provides a convenient way to reuse the common try ... except ... finally ... pattern. Consider this classic example: with open(&#39;file.txt&#39;) as f: content = f.read() In this code, no matter what happens during the execution of the block inside with, the file will eventually be closed. If an exception occurs during the execution of the block, the program will close the opened file before the exception is raised.</p><p>Now, let&#39;s look at another example.</p><p>When initiating a database transaction request, code like this is often used:</p><p>db.begin()</p><p>try:</p><h1 id="do-some-actions" tabindex="-1"><a class="header-anchor" href="#do-some-actions"><span>do some actions</span></a></h1><p>except: db.rollback() raise finally: db.commit() If the operation to initiate a transaction request is made to support the with keyword, then code like this can be used:</p><p>with transaction(db):</p><h1 id="do-some-actions-1" tabindex="-1"><a class="header-anchor" href="#do-some-actions-1"><span>do some actions</span></a></h1><p>Next, let&#39;s explain the execution process of with in detail and implement the above code in two common ways.</p><p>General Execution Process of with</p><p>A basic with expression has the following structure:</p><p>with EXPR as VAR: BLOCK Here, EXPR can be any expression, and as VAR is optional. The general execution process is as follows:</p><p>Evaluate EXPR to obtain a context manager. The context manager&#39;s <strong>exit</strong>() method is saved for later use. Call the context manager&#39;s <strong>enter</strong>() method. If the with expression includes as VAR, the return value of EXPR is assigned to VAR. Execute the expressions in BLOCK. Call the context manager&#39;s <strong>exit</strong>() method. If an exception occurred during the execution of BLOCK causing the program to exit, the exception&#39;s type, value, and traceback (i.e., the return values of sys.exc_info()) are passed as arguments to <strong>exit</strong>(). Otherwise, three None values are passed.</p><p>Expressing this process in code, it looks like this: mgr = (EXPR) exit = type(mgr).<strong>exit</strong> # Not executed here value = type(mgr).<strong>enter</strong>(mgr) exc = True</p><p>try: try: VAR = value # If there is &#39;as VAR&#39; BLOCK except: exc = False if not exit(mgr, *sys.exc_info()): raise finally: if exc: exit(mgr, None, None, None) There are a few details in this process:</p><p>If the context manager lacks either the <strong>enter</strong>() or <strong>exit</strong>() method, the interpreter will raise an AttributeError. After an exception occurs in BLOCK, if the <strong>exit</strong>() method returns a value that can be interpreted as True, the exception will not be raised, and subsequent code will continue to execute.</p><p>Next, let&#39;s implement the process described above using two methods. Implementing a Context Manager Class: The first method is to implement a class containing an instance attribute db and the required context manager methods <strong>enter</strong>() and <strong>exit</strong>().</p><p>class transaction(object): def <strong>init</strong>(self, db): self.db = db</p><p>def <strong>enter</strong>(self): self.db.begin()</p><p>def <strong>exit</strong>(self, type, value, traceback): if type is None: db.commit() else: db.rollback() Understanding the execution process of with, this implementation is straightforward. The implementation method introduced next is more complex in principle.</p><p>Using a Generator Decorator In Python&#39;s standard library, there is a decorator that can obtain a context manager from a generator. The implementation using the generator decorator is as follows:</p><p>@contextmanager def transaction(db): db.begin()</p><p>try: yield db except: db.rollback() raise else: db.commit() At first glance, this implementation seems simpler, but its mechanism is more complex. Let&#39;s look at its execution process:</p><p>The Python interpreter recognizes the yield keyword, and def creates a generator function instead of a regular function (outside class definitions, I prefer using functions over methods). The decorator contextmanager is called and returns a helper function. This helper function, when called, generates a GeneratorContextManager instance. Ultimately, the EXPR in the with expression calls the helper function returned by the contextmanager decorator. The with expression calls transaction(db), which actually calls the helper function. The helper function calls the generator function, which creates a generator. The helper function passes this generator to GeneratorContextManager and creates an instance object of GeneratorContextManager as the context manager. The with expression calls the context manager&#39;s <strong>enter</strong>() method of the instance object. The <strong>enter</strong>() method calls the generator&#39;s next() method. At this point, the generator method executes up to yield db and stops, returning db as the return value of next(). If there is as VAR, it will be assigned to VAR. The BLOCK within with is executed. After the BLOCK execution ends, the context manager&#39;s <strong>exit</strong>() method is called. The <strong>exit</strong>() method calls the generator&#39;s next() method again. If a StopIteration exception occurs, it is passed. If no exception occurred, the generator method will execute db.commit(); otherwise, it will execute db.rollback().</p><p>Let&#39;s look at the approximate code implementation of the above process again:</p><p>def contextmanager(func): def helper(*args, **kwargs): return GeneratorContextManager(func(*args, **kwargs)) return helper</p><p>class GeneratorContextManager(object): def <strong>init</strong>(self, gen): self.gen = gen</p><p>def <strong>enter</strong>(self): try: return self.gen.next() except StopIteration: raise RuntimeError(&quot;generator didn&#39;t yield&quot;)</p><p>def <strong>exit</strong>(self, type, value, traceback): if type is None: try: self.gen.next() except StopIteration: pass else: raise RuntimeError(&quot;generator didn&#39;t stop&quot;) else: try: self.gen.throw(type, value, traceback) raise RuntimeError(&quot;generator didn&#39;t stop after throw()&quot;) except StopIteration: return True except: if sys.exc_info()[1] is not value: raise Summary Python&#39;s with expression incorporates many Python features. Taking the time to thoroughly understand with is highly worthwhile.</p><p>Some Other Examples Lock Mechanism</p><p>@contextmanager def locked(lock): lock.acquired() try: yield finally: lock.release() Standard Output Redirection</p><p>@contextmanager def stdout_redirect(new_stdout): old_stdout = sys.stdout sys.stdout = new_stdout try: yield finally: sys.stdout = old_stdout</p><p>with open(&quot;file.txt&quot;, &quot;w&quot;) as f: with stdout_redirect(f): print &quot;hello world&quot; Reference Materials</p><p>The Python “with” Statement by Example</p>',35)]))}const l=t(a,[["render",i],["__file","article-1.html.vue"]]),h=JSON.parse(`{"path":"/blog/article-1.html","title":"Detailed explanation of the use of the with keyword in Python","lang":"en-US","frontmatter":{"layout":"BlogPost","date":"2025.01.12","archive":true,"title":"Detailed explanation of the use of the with keyword in Python","description":"The with keyword in Python 2.5 was introduced, and it provides a convenient way to reuse the common try ... except ... finally ... pattern. Consider this classic example"},"headers":[],"git":{"updatedTime":1754478598000,"contributors":[{"name":"limengli","username":"limengli","email":"limengli@qq.com","commits":1,"url":"https://github.com/limengli"}],"changelog":[{"hash":"33fb064215db0208e223b56976bfe0fd34434077","time":1754478598000,"email":"limengli@qq.com","author":"limengli","message":"web"}]},"filePathRelative":"blog/article-1.md","excerpt":"<p>In Python 2.5, the with keyword was introduced. It provides a convenient way to reuse the common try ... except ... finally ... pattern. Consider this classic example:\\nwith open('file.txt') as f:\\ncontent = f.read()\\nIn this code, no matter what happens during the execution of the block inside with, the file will eventually be closed. If an exception occurs during the execution of the block, the program will close the opened file before the exception is raised.</p>"}`);export{l as comp,h as data};
